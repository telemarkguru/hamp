# hamp
Hardware description meta programming in Python

A library with tools for generating and manipulating hardware descriptions at
Register Transfer Level (RTL).  The output is mainly FIRRTL
(https://github.com/chipsalliance/firrtl-spec/blob/main/spec.md) as this is
an excellent format for describing hardware as fundamental RTL
and it has great tools for e.g. generating Verilog.

The intention is to enable creation and manipulation of RTL programmatically
using meta-programming in Python.  This includes:

- Creating RTL modules
- Populating RTL modules with
    - Input ports
    - Output ports
    - Wires/signals
    - Registers
    - Memories
    - Instantiations of other modules
    - Behavioral code and connections
    - Meta-data about the module or its content

- Manipulate module hierarchies
- Manipulate modules:
    - Cloning a module and give it a new name
    - Add, remove and rename modules, ports, signals, code, instances,
      meta-data etc.

- Define RTL composite types (structs and arrays).

An example implementing a simple FIFO. Clock and reset are not explicitly
declared (though they can be), but inferred as registers with reset are
used.  The default clock is named "clk" and the default reset is named
"rst":

```Python
from hamp import module, input, output, wire, register, uint, u1, struct, flip


def create_fifo(size, data_type):

    @struct
    class fifo_if_type:
        valid: u1
        ready: flip(u1)
        data: data_type

    ptr_type = uint[(size-1).bit_length()]
    cnt_type = uint[size.bit_length()]

    m = module(f"fifo_{size}")
    m.push = input(fifo_if_type)
    m.pop = output(fifo_if_type)

    m.data = register(data_type[size], reset=False)
    m.iptr = register(ptr_type, value=0)
    m.optr = register(ptr_type, value=0)
    m.cnt = register(cnt_type, value=0)

    m.istb = wire(u1)
    m.ostb = wire(u1)

    @m.code
    def fifo(x):
        x.push.ready = x.cnt < size
        x.pop.valid = x.cnt > 0
        x.istb = x.push.valid and x.push.ready
        x.ostb = x.pop.valid and x.pop.ready
        x.pop.data = x.data[x.optr]
        if x.istb:
            x.data[iptr] = x.push.data
            x.iptr = (x.iptr + 1) % size
        if x.ostb:
            x.optr = (x.optr + 1) % size
        if x.istb and not x.ostb:
            x.cnt = x.cnt + 1
        elif x.ostb and not x.istb:
            x.cnt = x.cnt - 1

    return m, fifo_if_type


# Create FIFO module 42 deep, for 10-but unsigned integers:
fifo1, fifo1_if_type = create_fifo(42, uint[10])

# Add DFT ports:
fifo1.dft_in = input(some_dft_type1)
fifo1.dft_out = output(some_dft_type2)


# Use fifo1 module:

m = module("use_fifo1")
...
m.fifo = fifo1()

@m.code
def connect_fifo(x):
    x.fifo.push.valid = ...
    x.fifo.push.data = ...

    if x.fifo.pop.valid:
        ...
```

## Use model

The input Python code is first translated to an intermediate data format,
which is a nested data structure of dictionaries, lists, tuples, integers
and string. This data-format is defined in [here](doc/data-format.md).

The intermediate data-format can then be validated and translated into
FIRRTL.


## Data types

### Basic data types

The basic hardware data types are unsigned and signed integers of a specific
bit width.  These are declared like so:

```Python
from hamp import module, uint, sint, u1

m = module("example")
m.a = input(uint[10])  # a is an 10 bit unsigned integer input
m.b = output(sint[11])  # b is am 11 bit signed integer output
m.c = input(u1)  # For convenience, the very common
                 # 1 bit unsigned type is provided as u1
```

### Arrays

Arrays of any type (including arrays) can be defined.  This is done by
appending "[N]" where N is the size of the array. Example:

```Python
from hamp import uint

matrix3x5 = uint[8][3][5]  # An 5 elemet array of 3 element arrays of
                           # 8 bit unsigned integers.
```

### Composite data types

Composite data types are built on top of Pythons dataclasses, where the
fields are of basic hardware types, composite data types, or arrays of
these.  Example:

```Python
from hamp import struct, uint, sint, u1, flip, module

@struct
class Payload:
    x: sint[32]
    y: sint[32]
    data: uint[8][16]

@struct
class ValidReady:
    valid: u1
    ready: flip(u1)  # flip() will make ready have the opposite
                     # direction as the other members when used
                     # as input or output
    data: Payload[3]

m = module("foo")
m.din = input(ValidReady)
m.dout = output(ValidReady)
```


## Generating RTL code

RTL code is generated by executing Python code.  Operator overloading is used
to generate most expressions wile with-statements are used to generate control
statements (if/elif/else), like so:

```Python
m = module("mux")
m.a = input(uint[10])
m.b = input(uint[10])
m.x = output(uint[10])
m.sel = input(uint[1])

b = m.builder()
with b.if_stmt(m.sel):
    m.x = m.b
with b.else_stmt():
    m.x = m.a
```

But as this code may be cumbersome to read and write, function decorators are
provided that converts plain Python code to the format just described.  So that
the last 5 lines of the previous multiplexer example can be expressed as:

```Python
@m.code
def mux(m):
    if m.sel:
       m.x = m.b
    else:
       m.x = m.a
```

The @code decorator translates the if/else statements in the mux function to
the corresponding with-statement, so that the function can be executed to
generate RTL.

Apart from if/elif/else statements, *and*, *or* and *not* are translated to
function calls as these are not possible to overload in Python.

Functions can be translated using the @function decorator, like so:

```Python
@m.function
def wait(m, cycles):
    if m.timer == 0:
        m.timer = cycles
    else:
        m.timer = m.timer - 1
    if m.timer == 1:
        return 0
    return 1

@m.code
def fsm(m):
    ...
    if m.state = DO_STUFF:
        if wait(m, 3):
            m.state = STUFF_DONE
    ...
```

## Meta-programming

The *code* and *function* methods can also take a function passed as an
argument, and thereby allow functionality/logic inside a module to be
customized from outside.

```Python
def counter(name, update_func, rst_value):

    m = module(name)
    m.clk = input(clock())
    m.rst = input(reset())
    m.state = reg(uint[32], value=rst_value)
    m.update = input(u1)
    m.function(update_func)

    @m.code
    def main(m):
        if m.update:
            m.update_func(m)

    return m


def shift(m):
    if m.state[31]:
        m.state = 1
    else:
        m.state = m.state << 1


shift_counter = counter("shift_counter", shift, 1)

```
