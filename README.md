# hamp
Hardware description meta programming in Python

A library with tools for generating and manipulating hardware descriptions at
Register Transfer Level (RTL).  The output is mainly FIRRTL
(https://github.com/chipsalliance/firrtl-spec/blob/main/spec.md) as this is
an excellent format for describing hardware as fundamental RTL
and it has great tools for e.g. generating Verilog.

The intention is to enable creation and manipulation of RTL programmatically
using meta-programming in Python.  This includes:

- Creating RTL modules
- Populating RTL modules with
    - Input ports
    - Output ports
    - Wires/signals
    - Registers
    - Memories
    - Instantiations of other modules
    - Behavioral code and connections
    - Meta-data about the module or its content

- Manipulate module hierarchies
- Manipulate modules:
    - Cloning a module and give it a new name
    - Add, remove and rename modules, ports, signals, code, instances,
      meta-data etc.

- Define RTL composite types (structs and arrays).

A simple example:
```Python
from hamp import module, input, output, wire, register, uint


def create_fifo(size, data_type):

    u1 = uint[1]

    ptr_type = uint[(size-1).bit_length()]
    cnt_type = uint[size.bit_length()]

    m = module(f"fifo_{size}")
    m.in_valid = input(u1)
    m.in_ready = output(u1)
    m.in_data = input(data_type)
    m.out_valid = output(u1)
    m.out_ready = input(u1)
    m.out_data = output(data_type)

    m.data = register(data_type[size])
    m.iptr = register(ptr_type, reset_value=0)
    m.optr = register(ptr_type, reset_value=0)
    m.cnt = register(cnt_type, reset_value=0)

    m.istb = wire(u1)
    m.ostb = wire(u1)

    @m.code
    def fifo(mb):
        mb.in_ready = mb.cnt < size
        mb.out_valid = mb.cnt > 0
        mb.istb = mb.in_valid and mb.in_ready
        mb.ostb = mb.out_valid and mb.out_ready
        if mb.istb:
            mb.data[iptr] = mb.in_data
            mb.iptr = (mb.iptr + 1) % size
        if mb.ostb:
            mb.optr = (mb.optr + 1) % size
        if mb.istb and not mb.ostb:
            mb.cnt = mb.cnt + 1
        elif mb.ostb and not mb.istb:
            mb.cnt = mb.cnt - 1

    return m


fifo1 = create_fifo(42, uint[10])

# Add DFT ports:
fifo1.dft = input(dft_type)

```

## Data types

```Python
from hamp import struct
```

## Generating RTL code

RTL code is generated by executing Python code.  Operator overloading is used
to generate most expressions wile with-statements are used to generate control
statements (if/elif/else), like so:

```Python
m = module("mux")
m.a = input(uint[10])
m.b = input(uint[10])
m.x = output(uint[10])
m.sel = input(uint[1])

b = m.builder()
with b.if_stmt(m.sel):
    m.x = m.b
with b.else_stmt():
    m.x = m.a
```

But as this code may be cumbersome to read and write, function decorators are
provided that converts plain Python code to the format just described.
So the previous multiplexer example can also be expressed as:

```Python
@m.code
def mux(m):
    if m.sel:
       m.x = m.b
    else:
       m.x = m.a
```

The @code decorator translates the if/else statments in the mux function to the
corresponding with-statement, so that the function can be executed to generate
RTL.

Apart from if/elif/else statements, *and*, *or* and *not* are translated to
function calls as these are not overloadable operators in Python.

Functions can also be translated using the @function decorator, like so:

```Python
@m.function
def wait(m, cycles):
    if m.timer == 0:
        m.timer = cycles
    else:
        m.timer = m.timer - 1
    if m.timer == 1:
        return 0
    return 1

@m.code
def fsm(m):
    ...
    if m.state = DO_STUFF:
        if wait(m, 3):
            m.state = STUFF_DONE
    ...
```

## Function calls

```Python
from hamp import module, input, output, uint

dt = uint[32]
stages = 10

m = module("module)
m.din = input(dt)
m.dout = output(dt)
m.data = wire(dt[stages])

@m.function
def stage(mb, idx: int, value: int):
    mb.data[idx] = mb.data[idx-1] + value

@m.code
def main(mb):
    mb.data[0] = m.din
    for i in range(mb, 1, size):
        mb.stage(i, -42)
    mb.dout = m.data[size-1]

```
